<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Barcode-like Region Detection</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 0; padding: 0; }
    video, canvas { max-width: 100%; display: block; margin: auto; }
    #container { position: relative; display: inline-block; }
    #overlay, #lineCanvas {
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
    }
    #cropped { margin-top: 10px; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h2>Align and Tap to Detect Barcode-like Region</h2>
  <div id="container">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
    <canvas id="lineCanvas"></canvas>
  </div>
  <div>
    <h3>Cropped Area</h3>
    <canvas id="cropped"></canvas>
  </div>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const lineCanvas = document.getElementById('lineCanvas');
    const croppedCanvas = document.getElementById('cropped');
    const ctxOverlay = overlay.getContext('2d');
    const ctxLine = lineCanvas.getContext('2d');
    const brightnessThreshold = 100;

    let guideY = 0;

    // Start back camera
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: { exact: "environment" } }
    }).then(stream => {
      video.srcObject = stream;
    }).catch(() => {
      alert("Back camera not found. Trying default camera...");
      return navigator.mediaDevices.getUserMedia({ video: true });
    }).then(stream => {
      if (stream) video.srcObject = stream;
    });

    video.addEventListener('loadedmetadata', () => {
      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;
      overlay.style.width = video.offsetWidth + 'px';
      overlay.style.height = video.offsetHeight + 'px';

      lineCanvas.width = video.videoWidth;
      lineCanvas.height = video.videoHeight;
      lineCanvas.style.width = video.offsetWidth + 'px';
      lineCanvas.style.height = video.offsetHeight + 'px';

      guideY = Math.floor(video.videoHeight / 2);
      drawGuideLine();
    });

    function drawGuideLine() {
      ctxLine.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
      ctxLine.strokeStyle = 'red';
      ctxLine.lineWidth = 2;
      ctxLine.beginPath();
      ctxLine.moveTo(0, guideY);
      ctxLine.lineTo(lineCanvas.width, guideY);
      ctxLine.stroke();
    }

    overlay.addEventListener('click', async (e) => {
      const rect = overlay.getBoundingClientRect();
      const scaleX = video.videoWidth / rect.width;
      const scaleY = video.videoHeight / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX);

      const y = guideY;

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = video.videoWidth;
      tempCanvas.height = video.videoHeight;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(video, 0, 0);
      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      const data = imageData.data;

      function getBrightness(x, y) {
        const i = (y * tempCanvas.width + x) * 4;
        const r = data[i], g = data[i + 1], b = data[i + 2];
        return 0.299 * r + 0.587 * g + 0.114 * b;
      }

      function isDark(x, y) {
        return getBrightness(x, y) < brightnessThreshold;
      }

      // Check if vertical line at X is mostly dark
      function isVerticalLine(x) {
        let darkCount = 0;
        for (let i = 0; i < tempCanvas.height; i++) {
          if (isDark(x, i)) darkCount++;
        }
        return darkCount > tempCanvas.height * 0.4;
      }

      let startX = x, endX = x;
      while (startX > 0 && isVerticalLine(startX - 1)) startX--;
      while (endX < tempCanvas.width - 1 && isVerticalLine(endX + 1)) endX++;

      if (endX - startX < 5) {
        alert('No vertical lines found.');
        return;
      }

      // Determine top and bottom Y
      let topY = tempCanvas.height, bottomY = 0;
      for (let cx = startX; cx <= endX; cx++) {
        for (let cy = 0; cy < tempCanvas.height; cy++) {
          if (isDark(cx, cy)) {
            if (cy < topY) topY = cy;
            if (cy > bottomY) bottomY = cy;
          }
        }
      }

      ctxOverlay.clearRect(0, 0, overlay.width, overlay.height);
      ctxOverlay.strokeStyle = "lime";
      ctxOverlay.lineWidth = 2;
      ctxOverlay.strokeRect(startX, topY, endX - startX, bottomY - topY);

      const cropWidth = endX - startX;
      const cropHeight = bottomY - topY;
      if (cropWidth > 0 && cropHeight > 0) {
        const croppedCtx = croppedCanvas.getContext('2d');
        croppedCanvas.width = cropWidth;
        croppedCanvas.height = cropHeight;
        croppedCtx.putImageData(tempCtx.getImageData(startX, topY, cropWidth, cropHeight), 0, 0);
      }
    });
  </script>
</body>
</html>
