<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robust Symbol Detection</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="cv['onRuntimeInitialized']=onOpenCvReady;"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    canvas { border: 1px solid #ccc; margin: 10px; }
    .grid { display: flex; flex-wrap: wrap; gap: 10px; }
    #output { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Robust Symbol Detection (Rotation, Scale, Noise)</h1>
  <input type="file" accept="image/jpeg" id="upload" />
  <div id="status">Loading OpenCV...</div>
  <canvas id="inputCanvas" width="500" height="500"></canvas>
  <div id="output"></div>

  <script>
    let templates = [], templateIDs = [];
    const svgDefs = [
      `<svg viewBox="0 0 100 100"><path d="M10,10 L90,10 L50,50 L90,90 L10,90 L50,50 Z"/></svg>`,
      `<svg viewBox="0 0 100 100"><polygon points="10,10 45,10 90,55 90,90 55,90 10,45"/></svg>`,
      `<svg viewBox="0 0 100 100"><path d="M20,20 L80,20 L80,40 L40,40 L40,80 L20,80 Z"/></svg>`,
      `<svg viewBox="0 0 100 100"><path d="M10,10 L50,30 L90,10 L90,50 L70,50 L70,90 L30,90 L30,50 L10,50 Z"/></svg>`,
      `<svg viewBox="0 0 100 100"><path d="M10,10 L90,10 L90,30 L30,30 L30,70 L90,70 L90,90 L10,90 Z"/></svg>`,
      `<svg viewBox="0 0 100 100"><polygon points="20,20 80,20 80,40 60,60 80,80 80,100 20,100 20,80 40,60 20,40"/></svg>`,
      `<svg viewBox="0 0 100 100"><path d="M80,50a30,30 0 1 1-60,0a30,30 0 0 1 60,0z" fill="black"/><circle cx="65" cy="50" r="25" fill="white"/></svg>`,
      `<svg viewBox="0 0 100 100"><polygon points="50,10 90,60 70,60 70,90 30,90 30,60 10,60" fill="black"/></svg>`,
      `<svg viewBox="0 0 100 100"><rect width="100" height="100" fill="black"/></svg>`,
      `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="black"/></svg>`,
      `<svg viewBox="0 0 100 100"><rect x="10" y="10" width="80" height="80" fill="black"/><rect x="35" y="35" width="30" height="30" fill="white"/></svg>`,
      `<svg viewBox="0 0 100 100"><line x1="10" y1="50" x2="90" y2="50" stroke="black" stroke-width="15"/><line x1="50" y1="10" x2="50" y2="90" stroke="black" stroke-width="15"/></svg>`,
      `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="black"/><circle cx="50" cy="50" r="20" fill="white"/></svg>`,
      `<svg viewBox="0 0 100 100"><path d="M50,50 L90,50 A40,40 0 1 1 50,10 Z" fill="black"/></svg>`,
      `<svg viewBox="0 0 100 100"><polygon points="50,0 0,50 100,50" fill="black"/></svg>`,
      `<svg viewBox="0 0 100 100"><polygon points="50,0 0,50 100,50" fill="black"/><polygon points="100,50 50,0 50,100" fill="black"/></svg>`
    ];

    function svgToCanvas(svg, size = 100) {
      const img = new Image();
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      return new Promise(resolve => {
        const blob = new Blob([svg], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        img.onload = () => {
          ctx.clearRect(0, 0, size, size);
          ctx.drawImage(img, 0, 0, size, size);
          URL.revokeObjectURL(url);
          resolve(canvas);
        };
        img.src = url;
      });
    }

    async function loadTemplates() {
      for (let i = 0; i < svgDefs.length; i++) {
        const canvas = await svgToCanvas(svgDefs[i]);
        const mat = cv.imread(canvas);
        cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY);
        templates.push(mat);
        templateIDs.push(i);
      }
    }

    async function processImage(file) {
      const canvas = document.getElementById('inputCanvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = async () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        let src = cv.imread(canvas);
        cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);

        let orb = new cv.ORB();
        let keypoints1 = new cv.KeyPointVector();
        let descriptors1 = new cv.Mat();
        orb.detectAndCompute(src, new cv.Mat(), keypoints1, descriptors1);

        let results = [];

        for (let i = 0; i < templates.length; i++) {
          let temp = templates[i];
          let keypoints2 = new cv.KeyPointVector();
          let descriptors2 = new cv.Mat();
          orb.detectAndCompute(temp, new cv.Mat(), keypoints2, descriptors2);

          let matcher = new cv.BFMatcher(cv.NORM_HAMMING, true);
          let matches = new cv.DMatchVector();
          matcher.match(descriptors1, descriptors2, matches);

          let score = 0;
          for (let j = 0; j < matches.size(); j++) {
            score += matches.get(j).distance;
          }
          score = score / matches.size();

          if (matches.size() > 4 && score < 80) {
            results.push({ id: templateIDs[i], matchCount: matches.size(), score });
          }

          descriptors2.delete(); keypoints2.delete(); matches.delete();
        }

        descriptors1.delete(); keypoints1.delete(); orb.delete();
        results.sort((a, b) => a.score - b.score);

        const output = document.getElementById("output");
        output.innerHTML = `<h3>Detected Symbols:</h3>` +
          results.map(r => `Symbol ID: ${r.id}, Score: ${r.score.toFixed(2)}`).join("<br>");
      };
      img.src = URL.createObjectURL(file);
    }

    function onOpenCvReady() {
      document.getElementById("status").innerText = "OpenCV ready. Loading templates...";
      loadTemplates().then(() => {
        document.getElementById("status").innerText = "Templates loaded. Upload a JPEG image.";
      });
      document.getElementById("upload").addEventListener("change", e => {
        if (e.target.files.length > 0) {
          document.getElementById("status").innerText = "Processing image...";
          processImage(e.target.files[0]);
        }
      });
    }
  </script>
</body>
</html>
