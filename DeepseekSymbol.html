<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Working Symbol Matcher</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    #referenceSymbols {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }
    .symbol {
      text-align: center;
      padding: 10px;
      border: 1px solid #ddd;
    }
    canvas {
      max-width: 100%;
      border: 1px solid #ccc;
      margin: 10px 0;
    }
    #results {
      margin-top: 20px;
      padding: 10px;
      background: #f5f5f5;
    }
    .match {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .match svg {
      width: 50px;
      height: 50px;
      margin-right: 15px;
    }
    #status {
      padding: 10px;
      margin: 10px 0;
      background: #e3f2fd;
    }
    button:disabled {
      opacity: 0.5;
    }
    #processBtn {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Symbol Matcher</h1>
  
  <div id="status">Loading OpenCV.js...</div>
  
  <div id="referenceSymbols"></div>
  
  <input type="file" id="fileInput" accept="image/*" disabled>
  <button id="processBtn" disabled>Match Symbols</button>
  
  <div>
    <canvas id="inputCanvas"></canvas>
    <canvas id="outputCanvas"></canvas>
  </div>
  
  <div id="results">Waiting for initialization...</div>

  <!-- Reference SVGs -->
  <div id="svgTemplates" style="display: none;">
    <!-- ID: 0 -->
    <svg id="symbol0" viewBox="0 0 100 100">
      <path d="M10,10 L90,10 L50,50 L90,90 L10,90 L50,50 Z" />
    </svg>
    <!-- ID: 1 -->
    <svg id="symbol1" viewBox="0 0 100 100">
      <polygon points="10,10 45,10 90,55 90,90 55,90 10,45" />
    </svg>
    <!-- ID: 2 -->
    <svg id="symbol2" viewBox="0 0 100 100">
      <path d="M20,20 L80,20 L80,40 L40,40 L40,80 L20,80 Z" />
    </svg>
    <!-- ID: 3 -->
    <svg id="symbol3" viewBox="0 0 100 100">
      <path d="M10,10 L50,30 L90,10 L90,50 L70,50 L70,90 L30,90 L30,50 L10,50 Z" />
    </svg>
    <!-- ID: 4 -->
    <svg id="symbol4" viewBox="0 0 100 100">
      <path d="M10,10 L90,10 L90,30 L30,30 L30,70 L90,70 L90,90 L10,90 Z" />
    </svg>
    <!-- ID: 5 -->
    <svg id="symbol5" viewBox="0 0 100 100">
      <polygon points="20,20 80,20 80,40 60,60 80,80 80,100 20,100 20,80 40,60 20,40" />
    </svg>
    <!-- ID: 6 -->
    <svg id="symbol6" viewBox="0 0 100 100">
      <path d="M80,50a30,30 0 1 1-60,0a30,30 0 0 1 60,0z" fill="black"/>
      <circle cx="65" cy="50" r="25" fill="white"/>
    </svg>
    <!-- ID: 7 -->
    <svg id="symbol7" viewBox="0 0 100 100">
      <polygon points="50,10 90,60 70,60 70,90 30,90 30,60 10,60" fill="black"/>
    </svg>
    <!-- ID: 8 -->
    <svg id="symbol8" viewBox="0 0 100 100">
      <rect width="100" height="100" fill="black"/>
    </svg>
    <!-- ID: 9 -->
    <svg id="symbol9" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="40" fill="black"/>
    </svg>
    <!-- ID: 10 -->
    <svg id="symbol10" viewBox="0 0 100 100">
      <rect x="10" y="10" width="80" height="80" fill="black"/>
      <rect x="35" y="35" width="30" height="30" fill="white"/>
    </svg>
    <!-- ID: 11 -->
    <svg id="symbol11" viewBox="0 0 100 100">
      <line x1="10" y1="50" x2="90" y2="50" stroke="black" stroke-width="15"/>
      <line x1="50" y1="10" x2="50" y2="90" stroke="black" stroke-width="15"/>
    </svg>
    <!-- ID: 12 -->
    <svg id="symbol12" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="40" fill="black"/>
      <circle cx="50" cy="50" r="20" fill="white"/>
    </svg>
    <!-- ID: 13 -->
    <svg id="symbol13" viewBox="0 0 100 100">
      <path d="M50,50 L90,50 A40,40 0 1 1 50,10 Z" fill="black"/>
    </svg>
    <!-- ID: 14 -->
    <svg id="symbol14" viewBox="0 0 100 100">
      <polygon points="50,0 0,50 100,50" fill="black"/>
    </svg>
    <!-- ID: 15 -->
    <svg id="symbol15" viewBox="0 0 100 100">
      <polygon points="50,0 0,50 100,50" fill="black"/>
      <polygon points="100,50 50,0 50,100" fill="black"/>
    </svg>
  </div>

  <script>
    // Configuration
    const MIN_MATCHES = 10;
    const MATCH_RATIO = 0.7;
    const MAX_FEATURES = 500;
    
    // State
    let referenceDescriptors = [];
    let referenceKeypoints = [];
    let cvReady = false;
    let symbolsLoaded = 0;
    
    // Load OpenCV.js
    const script = document.createElement('script');
    script.src = 'https://docs.opencv.org/4.5.5/opencv.js';
    script.onload = initApp;
    script.onerror = () => updateStatus("Failed to load OpenCV.js", true);
    document.head.appendChild(script);

    function initApp() {
      cv['onRuntimeInitialized'] = () => {
        cvReady = true;
        updateStatus("OpenCV.js ready - loading reference symbols...");
        loadReferenceSymbols();
      };
    }

    function loadReferenceSymbols() {
      const container = document.getElementById('referenceSymbols');
      container.innerHTML = '';
      
      // Load visual references
      for (let i = 0; i < 16; i++) {
        const symbol = document.getElementById(`symbol${i}`).cloneNode(true);
        symbol.style.width = '80px';
        symbol.style.height = '80px';
        
        const div = document.createElement('div');
        div.className = 'symbol';
        div.appendChild(symbol);
        div.innerHTML += `<div>ID: ${i}</div>`;
        container.appendChild(div);
      }
      
      // Process reference symbols for matching
      updateStatus("Processing reference symbols...");
      
      // Process all symbols in sequence
      processSymbol(0);
    }

    function processSymbol(i) {
      if (i >= 16) {
        updateStatus("All reference symbols loaded. Ready to match!");
        document.getElementById('fileInput').disabled = false;
        document.getElementById('processBtn').disabled = false;
        document.getElementById('results').textContent = "Upload an image and click 'Match Symbols'";
        return;
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = 100;
      canvas.height = 100;
      const ctx = canvas.getContext('2d');
      
      // White background
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const svg = document.getElementById(`symbol${i}`);
      const svgData = new XMLSerializer().serializeToString(svg);
      const img = new Image();
      
      img.onload = function() {
        ctx.drawImage(img, 0, 0, 100, 100);
        
        // Process with OpenCV
        const src = cv.imread(canvas);
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        
        const processed = new cv.Mat();
        cv.threshold(gray, processed, 128, 255, cv.THRESH_BINARY_INV);
        
        const orb = new cv.ORB(MAX_FEATURES);
        const keypoints = new cv.KeyPointVector();
        const descriptors = new cv.Mat();
        orb.detectAndCompute(processed, new cv.Mat(), keypoints, descriptors);
        
        referenceDescriptors[i] = descriptors;
        referenceKeypoints[i] = keypoints;
        
        src.delete();
        gray.delete();
        processed.delete();
        
        symbolsLoaded++;
        updateStatus(`Loaded ${symbolsLoaded}/16 symbols...`);
        processSymbol(i + 1);
      };
      
      img.onerror = function() {
        updateStatus(`Failed to load symbol ${i}`, true);
        processSymbol(i + 1);
      };
      
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
    }

    function matchSymbols() {
      if (!cvReady) {
        updateStatus("OpenCV not ready yet", true);
        return;
      }
      
      const canvas = document.getElementById('inputCanvas');
      if (canvas.width === 0) {
        updateStatus("Please load an image first", true);
        return;
      }
      
      updateStatus("Starting symbol matching...");
      document.getElementById('processBtn').disabled = true;
      
      setTimeout(() => {
        try {
          // Process input image
          const src = cv.imread('inputCanvas');
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          
          const processed = new cv.Mat();
          cv.threshold(gray, processed, 128, 255, cv.THRESH_BINARY_INV);
          
          // Detect features
          const orb = new cv.ORB(MAX_FEATURES);
          const inputKeypoints = new cv.KeyPointVector();
          const inputDescriptors = new cv.Mat();
          orb.detectAndCompute(processed, new cv.Mat(), inputKeypoints, inputDescriptors);
          
          updateStatus(`Found ${inputKeypoints.size()} features in input image`);
          
          // Match against reference symbols
          const matches = [];
          const bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
          
          for (let i = 0; i < 16; i++) {
            if (!referenceDescriptors[i]) continue;
            
            const knnMatches = new cv.DMatchVectorVector();
            bf.knnMatch(inputDescriptors, referenceDescriptors[i], knnMatches, 2);
            
            // Apply ratio test
            const goodMatches = [];
            for (let j = 0; j < knnMatches.size(); j++) {
              const pair = knnMatches.get(j);
              if (pair.size() >= 2) {
                const m1 = pair.get(0);
                const m2 = pair.get(1);
                if (m1.distance < MATCH_RATIO * m2.distance) {
                  goodMatches.push(m1);
                }
              }
            }
            
            if (goodMatches.length >= MIN_MATCHES) {
              const confidence = goodMatches.length / MAX_FEATURES;
              matches.push({
                symbolId: i,
                confidence: confidence,
                matches: goodMatches
              });
            }
            
            knnMatches.delete();
          }
          
          // Show results
          if (matches.length > 0) {
            matches.sort((a, b) => b.confidence - a.confidence);
            showResults(matches);
            drawMatches(src, matches);
            updateStatus(`Matched ${matches.length} symbols!`);
          } else {
            updateStatus("No symbols matched. Try a clearer image.", true);
            document.getElementById('results').innerHTML = 
              "No symbols matched. Try:<br>" +
              "- Clearer image<br>" +
              "- Higher contrast<br>" + 
              "- Larger symbols";
          }
          
          // Clean up
          src.delete();
          gray.delete();
          processed.delete();
          inputKeypoints.delete();
          inputDescriptors.delete();
          orb.delete();
          bf.delete();
          
        } catch (err) {
          updateStatus(`Error: ${err.message}`, true);
          console.error(err);
        } finally {
          document.getElementById('processBtn').disabled = false;
        }
      }, 100);
    }

    function showResults(matches) {
      let html = '<h3>Matched Symbols:</h3>';
      
      matches.slice(0, 3).forEach(match => {
        const symbolId = match.symbolId;
        const confidence = Math.round(match.confidence * 100);
        const svg = document.getElementById(`symbol${symbolId}`).cloneNode(true);
        svg.style.width = '50px';
        svg.style.height = '50px';
        
        html += `
          <div class="match">
            ${svg.outerHTML}
            <div>
              <strong>Symbol ID:</strong> ${symbolId}<br>
              <strong>Confidence:</strong> ${confidence}%<br>
              <strong>Matches:</strong> ${match.matches.length}
            </div>
          </div>
        `;
      });
      
      document.getElementById('results').innerHTML = html;
    }

    function drawMatches(src, matches) {
      const output = new cv.Mat();
      cv.cvtColor(src, output, cv.COLOR_RGBA2RGB);
      
      // Draw all matches with different colors
      const colors = [
        new cv.Scalar(0, 255, 0),  // Green
        new cv.Scalar(0, 0, 255),   // Red
        new cv.Scalar(255, 0, 0)    // Blue
      ];
      
      for (let i = 0; i < Math.min(matches.length, 3); i++) {
        const match = matches[i];
        const color = colors[i % colors.length];
        
        match.matches.forEach(m => {
          const kp = referenceKeypoints[match.symbolId].get(m.trainIdx);
          cv.circle(output, kp.pt, 5, color, 2);
        });
      }
      
      cv.imshow('outputCanvas', output);
      output.delete();
    }

    function updateStatus(message, isError = false) {
      console.log(message);
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.style.background = isError ? '#ffebee' : '#e3f2fd';
      statusDiv.style.color = isError ? '#d32f2f' : 'inherit';
    }

    // Event listeners
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          const canvas = document.getElementById('inputCanvas');
          const ctx = canvas.getContext('2d');
          
          // Resize if too large
          const maxSize = 800;
          let width = img.width;
          let height = img.height;
          
          if (width > maxSize || height > maxSize) {
            const ratio = Math.min(maxSize/width, maxSize/height);
            width = Math.floor(width * ratio);
            height = Math.floor(height * ratio);
          }
          
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          updateStatus("Image loaded. Click 'Match Symbols'");
        };
        img.onerror = () => updateStatus("Failed to load image", true);
        img.src = event.target.result;
      };
      reader.onerror = () => updateStatus("Failed to read file", true);
      reader.readAsDataURL(file);
    });

    document.getElementById('processBtn').addEventListener('click', matchSymbols);
  </script>
</body>
</html>
