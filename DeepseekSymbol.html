<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Symbol Matcher (Fixed Version)</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    #referenceSymbols {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }
    .symbol {
      text-align: center;
      padding: 10px;
      border: 1px solid #ddd;
    }
    canvas {
      max-width: 100%;
      border: 1px solid #ccc;
      margin: 10px 0;
    }
    #status {
      padding: 10px;
      margin: 10px 0;
      background: #e3f2fd;
    }
    button:disabled {
      opacity: 0.5;
    }
    #processBtn {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .debug-container {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      margin-top: 20px;
    }
    .debug-entry {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }
    .match-result {
      display: flex;
      margin: 10px 0;
      padding: 10px;
      background: white;
      border-radius: 4px;
    }
    .symbol-preview svg {
      width: 50px;
      height: 50px;
      margin-right: 15px;
    }
    .debug-error {
      color: #dc3545;
      padding: 10px;
      background: #ffecec;
      border-radius: 4px;
    }
    .debug-suggestion {
      padding: 15px;
      background: #fff3cd;
      border-radius: 4px;
      margin-top: 10px;
    }
    .processing {
      text-align: center;
      padding: 20px;
    }
    .spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <h1>Symbol Matcher Ver12 </h1>
  
  <div id="status">Loading OpenCV.js...</div>
  
  <div id="referenceSymbols"></div>
  
  <input type="file" id="fileInput" accept="image/*" disabled>
  <button id="processBtn" disabled>Match Symbols</button>
  
  <div>
    <canvas id="inputCanvas"></canvas>
    <canvas id="debugCanvas"></canvas>
  </div>
  
  <div id="results">Waiting for initialization...</div>

  <!-- Reference SVGs -->
  <div id="svgTemplates" style="display: none;">
    <!-- ID: 0 -->
    <svg id="symbol0" viewBox="0 0 100 100">
      <path d="M10,10 L90,10 L50,50 L90,90 L10,90 L50,50 Z" />
    </svg>
    <!-- ID: 1 -->
    <svg id="symbol1" viewBox="0 0 100 100">
      <polygon points="10,10 45,10 90,55 90,90 55,90 10,45" />
    </svg>
    <!-- ID: 2 -->
    <svg id="symbol2" viewBox="0 0 100 100">
      <path d="M20,20 L80,20 L80,40 L40,40 L40,80 L20,80 Z" />
    </svg>
    <!-- ID: 3 -->
    <svg id="symbol3" viewBox="0 0 100 100">
      <path d="M10,10 L50,30 L90,10 L90,50 L70,50 L70,90 L30,90 L30,50 L10,50 Z" />
    </svg>
    <!-- ID: 4 -->
    <svg id="symbol4" viewBox="0 0 100 100">
      <path d="M10,10 L90,10 L90,30 L30,30 L30,70 L90,70 L90,90 L10,90 Z" />
    </svg>
    <!-- ID: 5 -->
    <svg id="symbol5" viewBox="0 0 100 100">
      <polygon points="20,20 80,20 80,40 60,60 80,80 80,100 20,100 20,80 40,60 20,40" />
    </svg>
    <!-- ID: 6 -->
    <svg id="symbol6" viewBox="0 0 100 100">
      <path d="M80,50a30,30 0 1 1-60,0a30,30 0 0 1 60,0z" fill="black"/>
      <circle cx="65" cy="50" r="25" fill="white"/>
    </svg>
    <!-- ID: 7 -->
    <svg id="symbol7" viewBox="0 0 100 100">
      <polygon points="50,10 90,60 70,60 70,90 30,90 30,60 10,60" fill="black"/>
    </svg>
    <!-- ID: 8 -->
    <svg id="symbol8" viewBox="0 0 100 100">
      <rect width="100" height="100" fill="black"/>
    </svg>
    <!-- ID: 9 -->
    <svg id="symbol9" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="40" fill="black"/>
    </svg>
    <!-- ID: 10 -->
    <svg id="symbol10" viewBox="0 0 100 100">
      <rect x="10" y="10" width="80" height="80" fill="black"/>
      <rect x="35" y="35" width="30" height="30" fill="white"/>
    </svg>
    <!-- ID: 11 -->
    <svg id="symbol11" viewBox="0 0 100 100">
      <line x1="10" y1="50" x2="90" y2="50" stroke="black" stroke-width="15"/>
      <line x1="50" y1="10" x2="50" y2="90" stroke="black" stroke-width="15"/>
    </svg>
    <!-- ID: 12 -->
    <svg id="symbol12" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="40" fill="black"/>
      <circle cx="50" cy="50" r="20" fill="white"/>
    </svg>
    <!-- ID: 13 -->
    <svg id="symbol13" viewBox="0 0 100 100">
      <path d="M50,50 L90,50 A40,40 0 1 1 50,10 Z" fill="black"/>
    </svg>
    <!-- ID: 14 -->
    <svg id="symbol14" viewBox="0 0 100 100">
      <polygon points="50,0 0,50 100,50" fill="black"/>
    </svg>
    <!-- ID: 15 -->
    <svg id="symbol15" viewBox="0 0 100 100">
      <polygon points="50,0 0,50 100,50" fill="black"/>
      <polygon points="100,50 50,0 50,100" fill="black"/>
    </svg>
  </div>

  <script>
    // Configuration
    const MIN_MATCHES = 5;
    const MATCH_RATIO = 0.7;
    const MAX_FEATURES = 500;
    const NUM_SYMBOLS = 16;
    
    // State
    let referenceDescriptors = [];
    let referenceKeypoints = [];
    let cvReady = false;
    let symbolsLoaded = 0;
    
    // Load OpenCV.js
    const script = document.createElement('script');
    script.src = 'https://docs.opencv.org/4.5.5/opencv.js';
    script.onload = initApp;
    script.onerror = () => updateStatus("Failed to load OpenCV.js", true);
    document.head.appendChild(script);

    function initApp() {
      cv['onRuntimeInitialized'] = () => {
        cvReady = true;
        updateStatus("OpenCV.js ready - loading reference symbols...");
        loadReferenceSymbols();
      };
    }

    function loadReferenceSymbols() {
      const container = document.getElementById('referenceSymbols');
      container.innerHTML = '';
      
      // Create all reference symbol containers
      for (let i = 0; i < NUM_SYMBOLS; i++) {
        const div = document.createElement('div');
        div.className = 'symbol';
        div.innerHTML = `<div>ID: ${i}</div>`;
        container.appendChild(div);
      }
      
      // Process each symbol
      updateStatus("Processing reference symbols...");
      processSymbol(0);
    }

    function processSymbol(i) {
      if (i >= NUM_SYMBOLS) {
        updateStatus("All reference symbols loaded. Ready to match!");
        document.getElementById('fileInput').disabled = false;
        document.getElementById('processBtn').disabled = false;
        document.getElementById('results').textContent = "Upload an image and click 'Match Symbols'";
        return;
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = 100;
      canvas.height = 100;
      const ctx = canvas.getContext('2d');
      
      // White background
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const svg = document.getElementById(`symbol${i}`);
      const svgData = new XMLSerializer().serializeToString(svg);
      const img = new Image();
      
      img.onload = function() {
        ctx.drawImage(img, 0, 0, 100, 100);
        
        try {
          // Process with OpenCV
          const src = cv.imread(canvas);
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
          
          // Enhanced preprocessing
          const equalized = new cv.Mat();
          cv.equalizeHist(gray, equalized);
          
          const processed = new cv.Mat();
          cv.adaptiveThreshold(
            equalized,
            processed,
            255,
            cv.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv.THRESH_BINARY_INV,
            11,
            2
          );
          
          const orb = new cv.ORB(MAX_FEATURES);
          const keypoints = new cv.KeyPointVector();
          const descriptors = new cv.Mat();
          orb.detectAndCompute(processed, new cv.Mat(), keypoints, descriptors);
          
          referenceDescriptors[i] = descriptors;
          referenceKeypoints[i] = keypoints;
          
          // Update display
          const symbolDiv = document.querySelector(`#referenceSymbols .symbol:nth-child(${i+1})`);
          symbolDiv.prepend(canvas);
          
          // Cleanup
          [src, gray, equalized, processed].forEach(m => m.delete());
          
          symbolsLoaded++;
          updateStatus(`Loaded ${symbolsLoaded}/${NUM_SYMBOLS} symbols...`);
          processSymbol(i + 1);
        } catch (err) {
          updateStatus(`Error processing symbol ${i}: ${err.message}`, true);
          console.error(err);
          processSymbol(i + 1);
        }
      };
      
      img.onerror = function() {
        updateStatus(`Failed to load symbol ${i}`, true);
        processSymbol(i + 1);
      };
      
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
    }

 




function matchSymbols() {
  // Reset UI
  document.getElementById('results').innerHTML = `
    <div class="debug-container">
      <h3>Matching Process</h3>
      <div id="debugLog"></div>
      <div id="matchResults"></div>
      <div id="imageAnalysis">
        <h4>Image Analysis</h4>
        <canvas id="debugCanvas" width="200" height="200"></canvas>
        <div id="featureInfo"></div>
      </div>
    </div>
  `;

  const debugLog = document.getElementById('debugLog');
  const debugCanvas = document.getElementById('debugCanvas');
  const featureInfo = document.getElementById('featureInfo');

  function logDebug(message) {
    const entry = document.createElement('div');
    entry.className = 'debug-entry';
    entry.textContent = `â€¢ ${message}`;
    debugLog.appendChild(entry);
    console.log(message);
  }

  // Declare all OpenCV objects
  let src, gray, equalized, processed, descriptors, orb, bf;
  let keypoints = new cv.KeyPointVector();

  try {
    // 1. Verify OpenCV is ready
    if (!window.cv) throw new Error("OpenCV not loaded");
    logDebug("OpenCV is ready");

    // 2. Load and verify input image
    const inputCanvas = document.getElementById('inputCanvas');
    if (!inputCanvas || inputCanvas.width === 0) {
      throw new Error("No image loaded");
    }
    logDebug(`Input image loaded (${inputCanvas.width}x${inputCanvas.height})`);

    // 3. Enhanced image processing
    src = cv.imread('inputCanvas');
    gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    
    // Apply histogram equalization
    equalized = new cv.Mat();
    cv.equalizeHist(gray, equalized);
    
    // Apply adaptive thresholding
    processed = new cv.Mat();
    cv.adaptiveThreshold(
      equalized,
      processed,
      255,
      cv.ADAPTIVE_THRESH_GAUSSIAN_C,
      cv.THRESH_BINARY_INV,
      11,
      2
    );
    
    // Show processed image
    cv.imshow('debugCanvas', processed);
    logDebug("Image processed (equalized + thresholded)");

    // 4. Feature detection with proper mask
    orb = new cv.ORB(MAX_FEATURES);
    descriptors = new cv.Mat();
    
    // Create empty mask
    const mask = new cv.Mat();
    orb.detectAndCompute(processed, mask, keypoints, descriptors);
    mask.delete();
    
    const featureCount = keypoints.size();
    featureInfo.innerHTML = `
      <p>Features detected: <strong>${featureCount}</strong></p>
      ${featureCount > 0 ? `<p>Average feature size: ${getAverageFeatureSize(keypoints)}px</p>` : ''}
    `;
    logDebug(`Detected ${featureCount} features`);

    if (featureCount < 10) {
      throw new Error(`Only ${featureCount} features found - image may need better contrast or sharper edges`);
    }

    // 5. Matching with reference symbols
    const matches = [];
    bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
    
    for (let i = 0; i < NUM_SYMBOLS; i++) {
      if (!referenceDescriptors[i] || referenceDescriptors[i].empty()) {
        logDebug(`Skipping symbol ${i} - no descriptors`);
        continue;
      }
      
      try {
        const matchResults = new cv.DMatchVector();
        bf.match(descriptors, referenceDescriptors[i], matchResults);
        
        // Calculate match statistics with proper distance handling
        let minDistance = Infinity;
        let maxDistance = 0;
        const goodMatches = [];
        
        for (let j = 0; j < matchResults.size(); j++) {
          try {
            const m = matchResults.get(j);
            // Ensure distance is treated as a number
            const distance = typeof m.distance === 'object' ? m.distance.toFixed(0) : m.distance;
            minDistance = Math.min(minDistance, distance);
            maxDistance = Math.max(maxDistance, distance);
            
            if (distance < 50) {
              goodMatches.push(m);
            }
          } catch (e) {
            console.warn(`Error processing match ${j} for symbol ${i}:`, e);
          }
        }
        
        logDebug(`Symbol ${i}: ${goodMatches.length} good matches (distances ${minDistance}-${maxDistance})`);
        
        if (goodMatches.length >= MIN_MATCHES) {
          matches.push({
            symbolId: i,
            confidence: Math.min(100, (goodMatches.length / featureCount) * 200),
            matches: goodMatches
          });
        }
        
        matchResults.delete();
      } catch (e) {
        console.error(`Error matching symbol ${i}:`, e);
        logDebug(`Error matching symbol ${i} - skipping`);
      }
    }

    // 6. Display results
    if (matches.length > 0) {
      displayMatchResults(matches);
    } else {
      displayNoMatches(featureCount);
    }

  } catch (err) {
    handleError(err);
    
    // Additional troubleshooting for low feature count
    if (err.message.includes("features found")) {
      debugLog.innerHTML += `
        <div class="debug-suggestion">
          <h4>Troubleshooting Tips</h4>
          <ol>
            <li>Try a higher contrast image (black symbols on white background)</li>
            <li>Make symbols larger in the image (at least 100x100 pixels)</li>
            <li>Use simpler shapes that match the reference symbols exactly</li>
            <li>Ensure good lighting with no shadows or glare</li>
          </ol>
          <button onclick="testWithSampleImage()">Test with Sample Image</button>
        </div>
      `;
    }
  } finally {
    // Clean up OpenCV objects
    [src, gray, equalized, processed, descriptors, orb, bf].forEach(obj => {
      if (obj && !obj.isDeleted) obj.delete();
    });
    if (keypoints && !keypoints.isDeleted) keypoints.delete();
    document.getElementById('processBtn').disabled = false;
  }

  function displayMatchResults(matches) {
    let resultsHTML = '<h3>Matches Found:</h3>';
    matches.sort((a, b) => b.confidence - a.confidence).forEach(match => {
      const symbolSvg = document.getElementById(`symbol${match.symbolId}`)?.outerHTML || `Symbol ${match.symbolId}`;
      resultsHTML += `
        <div class="match-result">
          <div class="symbol-preview">${symbolSvg}</div>
          <div class="match-details">
            <p>Symbol ID: ${match.symbolId}</p>
            <p>Confidence: ${match.confidence.toFixed(1)}%</p>
            <p>Matches: ${match.matches.length}</p>
          </div>
        </div>
      `;
    });
    document.getElementById('matchResults').innerHTML = resultsHTML;
    logDebug(`Found ${matches.length} potential matches`);
  }

  function displayNoMatches(featureCount) {
    document.getElementById('matchResults').innerHTML = `
      <div class="no-matches">
        <h3>No Matches Found</h3>
        <div class="diagnosis">
          <p>Detected ${featureCount} features but found no matches.</p>
          <p><strong>Possible solutions:</strong></p>
          <ol>
            <li>Ensure symbols match the reference shapes exactly</li>
            <li>Try higher contrast between symbol and background</li>
            <li>Use sharper images with better lighting</li>
            <li>Make symbols larger in the image</li>
          </ol>
        </div>
      </div>
    `;
    logDebug("No matches met the confidence threshold");
  }

  function handleError(err) {
    const errorMessage = err.message || "Unknown error occurred";
    debugLog.innerHTML += `
      <div class="debug-error">
        <h4>Error Occurred</h4>
        <p>${errorMessage}</p>
        <p>Check browser console for details</p>
      </div>
    `;
    console.error("Matching error:", err);
    
    // Additional error diagnostics
    console.log("OpenCV objects status:", {
      src: src && !src.isDeleted,
      gray: gray && !gray.isDeleted,
      equalized: equalized && !equalized.isDeleted,
      processed: processed && !processed.isDeleted,
      descriptors: descriptors && !descriptors.isDeleted,
      keypoints: keypoints && !keypoints.isDeleted
    });
  }
}









      

      function displayMatchResults(matches) {
        let resultsHTML = '<h3>Matches Found:</h3>';
        matches.sort((a, b) => b.confidence - a.confidence).forEach(match => {
          const symbolSvg = document.getElementById(`symbol${match.symbolId}`)?.outerHTML || `Symbol ${match.symbolId}`;
          resultsHTML += `
            <div class="match-result">
              <div class="symbol-preview">${symbolSvg}</div>
              <div class="match-details">
                <p>Symbol ID: ${match.symbolId}</p>
                <p>Confidence: ${match.confidence.toFixed(1)}%</p>
                <p>Matches: ${match.matches.length}</p>
              </div>
            </div>
          `;
        });
        document.getElementById('matchResults').innerHTML = resultsHTML;
        logDebug(`Found ${matches.length} potential matches`);
      }

      function displayNoMatches(featureCount) {
        document.getElementById('matchResults').innerHTML = `
          <div class="no-matches">
            <h3>No Matches Found</h3>
            <div class="diagnosis">
              <p>Detected ${featureCount} features but found no matches.</p>
              <p><strong>Possible solutions:</strong></p>
              <ol>
                <li>Ensure symbols match the reference shapes exactly</li>
                <li>Try higher contrast between symbol and background</li>
                <li>Use sharper images with better lighting</li>
                <li>Make symbols larger in the image</li>
              </ol>
            </div>
          </div>
        `;
        logDebug("No matches met the confidence threshold");
      }

      function handleError(err) {
        const errorMessage = err.message || "Unknown error occurred";
        debugLog.innerHTML += `
          <div class="debug-error">
            <h4>Error Occurred</h4>
            <p>${errorMessage}</p>
            <p>Check browser console for details</p>
          </div>
        `;
        console.error("Matching error:", err);
        
        // Additional error diagnostics
        console.log("OpenCV objects status:", {
          src: src && !src.isDeleted,
          gray: gray && !gray.isDeleted,
          descriptors: descriptors && !descriptors.isDeleted,
          keypoints: keypoints && !keypoints.isDeleted
        });
      }
    }

    function getAverageFeatureSize(keypoints) {
      if (!keypoints || keypoints.size() === 0) return "0";
      let totalSize = 0;
      for (let i = 0; i < keypoints.size(); i++) {
        try {
          totalSize += keypoints.get(i).size;
        } catch (e) {
          console.warn(`Error getting keypoint ${i}:`, e);
        }
      }
      return (totalSize / keypoints.size()).toFixed(1);
    }

    function testWithSampleImage() {
      const canvas = document.getElementById('inputCanvas');
      const ctx = canvas.getContext('2d');
      
      // Create a test image (Symbol 0 - hexagon)
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(70, 20);
      ctx.lineTo(120, 20);
      ctx.lineTo(150, 60);
      ctx.lineTo(120, 100);
      ctx.lineTo(70, 100);
      ctx.lineTo(40, 60);
      ctx.closePath();
      ctx.fill();
      
      // Run matching
      matchSymbols();
    }

    function updateStatus(message, isError = false) {
      console.log(message);
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.style.background = isError ? '#ffebee' : '#e3f2fd';
      statusDiv.style.color = isError ? '#d32f2f' : 'inherit';
    }

    // Event listeners
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          const canvas = document.getElementById('inputCanvas');
          const ctx = canvas.getContext('2d');
          
          // Resize if too large
          const maxSize = 800;
          let width = img.width;
          let height = img.height;
          
          if (width > maxSize || height > maxSize) {
            const ratio = Math.min(maxSize/width, maxSize/height);
            width = Math.floor(width * ratio);
            height = Math.floor(height * ratio);
          }
          
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          updateStatus("Image loaded. Click 'Match Symbols'");
        };
        img.onerror = () => updateStatus("Failed to load image", true);
        img.src = event.target.result;
      };
      reader.onerror = () => updateStatus("Failed to read file", true);
      reader.readAsDataURL(file);
    });

    document.getElementById('processBtn').addEventListener('click', matchSymbols);
  </script>
</body>
</html>
