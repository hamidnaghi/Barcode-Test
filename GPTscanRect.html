<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Rectangle Detection and Crop</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    canvas { max-width: 100%; border: 1px solid #ccc; margin-top: 10px; }
    #output canvas { margin-top: 20px; }
  </style>
</head>
<body>

<h2>Upload Image to Detect and Crop Rectangle</h2>
<input type="file" id="imageInput" accept="image/*" />
<p id="status">Waiting for OpenCV...</p>

<canvas id="canvasInput"></canvas>

<div id="output">
  <h3>Cropped Rectangle:</h3>
  <canvas id="canvasOutput"></canvas>
</div>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="cv['onRuntimeInitialized']=onOpenCvReady;"></script>

<script>
function onOpenCvReady() {
  document.getElementById("status").textContent = "OpenCV is ready. Please upload an image.";

  document.getElementById("imageInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const img = new Image();
    img.onload = () => {
      const canvas = document.getElementById("canvasInput");
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      detectRectangle(canvas);
    };
    img.src = URL.createObjectURL(file);
  });
}

function detectRectangle(canvas) {
  const src = cv.imread(canvas);
  const gray = new cv.Mat();
  const blur = new cv.Mat();
  const edges = new cv.Mat();
  const contours = new cv.MatVector();
  const hierarchy = new cv.Mat();

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
  cv.Canny(blur, edges, 50, 150);
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let largestRect = null;
  let largestArea = 0;

  for (let i = 0; i < contours.size(); i++) {
    const contour = contours.get(i);
    const approx = new cv.Mat();
    cv.approxPolyDP(contour, approx, 0.02 * cv.arcLength(contour, true), true);

    if (approx.rows === 4 && cv.isContourConvex(approx)) {
      const area = cv.contourArea(approx);
      if (area > largestArea) {
        largestArea = area;
        largestRect = approx;
      } else {
        approx.delete();
      }
    } else {
      approx.delete();
    }
  }

  if (largestRect) {
    const points = [];
    for (let i = 0; i < 4; i++) {
      points.push({ x: largestRect.data32S[i * 2], y: largestRect.data32S[i * 2 + 1] });
    }

    // Sort points in order: top-left, top-right, bottom-right, bottom-left
    points.sort((a, b) => a.y - b.y);
    const top = points.slice(0, 2).sort((a, b) => a.x - b.x);
    const bottom = points.slice(2).sort((a, b) => a.x - b.x);
    const ordered = [top[0], top[1], bottom[1], bottom[0]];

    const [tl, tr, br, bl] = ordered;
    const width = Math.max(
      Math.hypot(tr.x - tl.x, tr.y - tl.y),
      Math.hypot(br.x - bl.x, br.y - bl.y)
    );
    const height = Math.max(
      Math.hypot(bl.x - tl.x, bl.y - tl.y),
      Math.hypot(br.x - tr.x, br.y - tr.y)
    );

    const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      tl.x, tl.y,
      tr.x, tr.y,
      br.x, br.y,
      bl.x, bl.y,
    ]);
    const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      0, 0,
      width, 0,
      width, height,
      0, height,
    ]);

    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const dst = new cv.Mat();
    cv.warpPerspective(src, dst, M, new cv.Size(width, height));

    cv.imshow("canvasOutput", dst);

    dst.delete(); srcTri.delete(); dstTri.delete(); M.delete(); largestRect.delete();
  } else {
    alert("No rectangle found.");
  }

  src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
}
</script>

</body>
</html>
