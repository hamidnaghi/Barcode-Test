<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Media Sequence Viewer with Pointer</title>
    <style>
        /* [Previous CSS content remains exactly the same] */
    </style>
</head>
<body>
    <!-- [Previous HTML content remains exactly the same until the script section] -->

    <script>
        // Configuration - EDIT THESE TO MATCH YOUR FILES
        const mediaFiles = [
            { 
                media: "pic1.jpg", 
                audio: "sound1.mp3", 
                caption: "برای اینکه مکالمه را از صحبت منفی در مورد کسی که در آن صحنه حضور ندارد دور کنید، می توانید به آرامی مکالمه را تغییر دهید و در مورد آن شخص غایب موارد مثبتی مطرح کنید, بدین ترتیب لحن محترمانه ای در گفتگو ادامه پیدا خواهد کرد.",
                pointerPath: [
                    { x: 20, y: 20, wait: 10000 },
                    { x: 80, y: 30, wait: 15000 },
                    { x: 50, y: 70, wait: 20000 }
                ]
            },
            { 
                media: "pic2.jpg", 
                audio: "sound2.mp3", 
                caption: "نپرسید کشورتان برای شما چه کرده است، بلکه بپرسید شما برای کشورتان چه کرده‌اید - جان اف کندی",
                pointerPath: [
                    { x: 10, y: 10, wait: 8000 },
                    { x: 90, y: 20, wait: 12000 },
                    { x: 40, y: 60, wait: 25000 }
                ]
            },
            { 
                media: "hamid.gif", 
                audio: "sound3.mp3", 
                caption: "آن که پل‌های پشت سرش را به فراموشی می‌سپارد، دیر یا زود درمی‌یابد که راه پیش رو، بدون دست یاری دیگران، دشوارتر از آن است که می‌پنداشت.",
                pointerPath: [
                    { x: 30, y: 40, wait: 15000 },
                    { x: 70, y: 50, wait: 18000 },
                    { x: 20, y: 80, wait: 12000 }
                ]
            }
        ];
        
        // State management
        const state = {
            currentIndex: 0,
            isPlaying: false,
            enablePreload: false,
            currentTransition: 'fade',
            audioDurations: [],
            preloadedMedia: [],
            timers: {
                progress: null,
                countdown: null,
                transition: null,
                pointer: null
            },
            isPreloading: false,
            currentPointerPath: [],
            mediaLoadAttempts: 0
        };
        
        // [Previous DOM elements cache remains the same]

        // Initialize the application
        async function init() {
            setupEventListeners();
            await loadAudioDurations();
            updateUI();
            showSlide(state.currentIndex);
        }
        
        // [Previous loadAudioDurations(), getAudioDuration(), preloadMedia(), 
        // showLoading(), showError(), updateUI(), updatePointerPathTable() functions remain the same]

        // Move pointer along the defined path
        function movePointerAlongPath() {
            clearTimeout(state.timers.pointer);
            
            const path = state.currentPointerPath;
            if (!path || path.length === 0) {
                elements.pointer.style.display = 'none';
                return;
            }
            
            let currentPointIndex = 0;
            elements.pointer.style.display = 'block';
            
            function moveToNextPoint() {
                if (currentPointIndex >= path.length) {
                    elements.pointer.style.display = 'none';
                    return;
                }
                
                const point = path[currentPointIndex];
                const mediaRect = elements.currentMedia.getBoundingClientRect();
                const containerRect = elements.currentMedia.parentElement.getBoundingClientRect();
                
                // Calculate positions
                const xPos = (point.x / 100) * mediaRect.width;
                const yPos = (point.y / 100) * mediaRect.height;
                const pointerX = containerRect.left + xPos;
                const pointerY = containerRect.top + yPos;
                
                // Apply smooth transition
                elements.pointer.style.left = `${pointerX}px`;
                elements.pointer.style.top = `${pointerY}px`;
                
                currentPointIndex++;
                
                if (currentPointIndex < path.length) {
                    state.timers.pointer = setTimeout(moveToNextPoint, 3000 + path[currentPointIndex].wait);
                }
            }
            
            // Initialize first position immediately without animation
            const firstPoint = path[0];
            const mediaRect = elements.currentMedia.getBoundingClientRect();
            const containerRect = elements.currentMedia.parentElement.getBoundingClientRect();
            const firstXPos = (firstPoint.x / 100) * mediaRect.width;
            const firstYPos = (firstPoint.y / 100) * mediaRect.height;
            const firstPointerX = containerRect.left + firstXPos;
            const firstPointerY = containerRect.top + firstYPos;
            
            elements.pointer.style.transition = 'none';
            elements.pointer.style.left = `${firstPointerX}px`;
            elements.pointer.style.top = `${firstPointerY}px`;
            
            // Force reflow
            void elements.pointer.offsetWidth;
            
            // Enable transition for subsequent movements
            elements.pointer.style.transition = 'left 3s ease-in-out, top 3s ease-in-out';
            
            // Start moving to next points
            state.timers.pointer = setTimeout(() => {
                moveToNextPoint();
            }, firstPoint.wait);
        }

        // Apply transition effect between slides
        async function applyTransition(newIndex, direction = 'next') {
            if (state.isPreloading) {
                console.warn("Media still preloading, transition may not be smooth");
                showSlideContent(newIndex);
                return;
            }
            
            const currentMedia = elements.currentMedia;
            const nextMedia = elements.nextMedia;
            const file = mediaFiles[newIndex];
            
            try {
                // Reset error state
                showError(false);
                state.mediaLoadAttempts = 0;
                
                // Preload next media
                nextMedia.src = file.media;
                nextMedia.style.opacity = '0';
                
                // Wait for media to load with timeout
                await new Promise((resolve, reject) => {
                    let loaded = false;
                    
                    const loadHandler = () => {
                        if (!loaded) {
                            loaded = true;
                            resolve();
                        }
                    };
                    
                    const errorHandler = () => {
                        if (!loaded) {
                            loaded = true;
                            state.mediaLoadAttempts++;
                            if (state.mediaLoadAttempts < 3) {
                                console.log(`Retrying media load (attempt ${state.mediaLoadAttempts})`);
                                setTimeout(() => {
                                    nextMedia.src = file.media;
                                }, 1000);
                            } else {
                                reject(new Error(`Failed to load media after 3 attempts: ${file.media}`));
                            }
                        }
                    };
                    
                    const timeout = setTimeout(() => {
                        if (!loaded) {
                            loaded = true;
                            console.warn(`Media load timeout: ${file.media}`);
                            resolve(); // Continue even if timeout
                        }
                    }, 5000);
                    
                    nextMedia.onload = loadHandler;
                    nextMedia.onerror = errorHandler;
                    
                    if (nextMedia.complete) {
                        loadHandler();
                    }
                });
                
                // Apply transition effect
                switch(state.currentTransition) {
                    case 'fade':
                        currentMedia.classList.add('fade-out');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        showSlideContent(newIndex);
                        break;
                        
                    case 'slide':
                        currentMedia.classList.add(direction === 'next' ? 'slide-left' : 'slide-right');
                        nextMedia.style.transform = direction === 'next' ? 'translateX(100%)' : 'translateX(-100%)';
                        nextMedia.style.opacity = '1';
                        await new Promise(resolve => setTimeout(resolve, 500));
                        showSlideContent(newIndex);
                        break;
                        
                    case 'zoom':
                        currentMedia.classList.add('zoom-out');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        showSlideContent(newIndex);
                        break;
                        
                    default:
                        showSlideContent(newIndex);
                        break;
                }
            } catch (error) {
                console.error("Transition error:", error);
                showError(true, `Error loading media: ${file.media}. Please check file exists.`);
            }
        }

        // Show slide content (without transition)
        function showSlideContent(index) {
            try {
                state.currentIndex = index;
                const file = mediaFiles[index];
                
                // Set current pointer path
                state.currentPointerPath = file.pointerPath || [];
                updatePointerPathTable(state.currentPointerPath);
                
                // Swap media elements
                const temp = elements.currentMedia.src;
                elements.currentMedia.src = elements.nextMedia.src;
                elements.nextMedia.src = temp;
                
                // Reset styles
                elements.currentMedia.classList.remove('fade-out', 'slide-left', 'slide-right', 'zoom-out');
                elements.currentMedia.style.opacity = '1';
                elements.currentMedia.style.transform = 'none';
                elements.nextMedia.style.opacity = '0';
                elements.nextMedia.style.transform = 'none';
                
                // Update caption
                elements.currentCaption.textContent = file.caption;
                
                // Update audio
                elements.currentAudio.src = file.audio;
                
                // Play audio if autoplay is enabled
                if (state.isPlaying) {
                    elements.currentAudio.currentTime = 0;
                    elements.currentAudio.play().catch(e => {
                        console.log("Autoplay prevented:", e);
                        // If autoplay is blocked, start the timer manually
                        startAutoPlay();
                    });
                    movePointerAlongPath();
                }
                
                // Update UI
                updateUI();
                updateButtonStates();
                
                // Reset progress
                elements.progressBar.style.width = '0%';
                
            } catch (error) {
                console.error("Error showing slide:", error);
                showError(true, "Error displaying slide content. Please check console for details.");
            }
        }

        // Show a specific slide with transition
        function showSlide(index, direction = 'next') {
            if (index < 0 || index >= mediaFiles.length) return;
            
            clearTimers();
            applyTransition(index, direction);
            
            if (state.isPlaying) {
                startAutoPlay();
            }
        }

        // Start auto-play using audio duration
        function startAutoPlay() {
            clearTimers();
            
            const duration = state.audioDurations[state.currentIndex] || 
                           mediaFiles[state.currentIndex].pointerPath.reduce((sum, p) => sum + p.wait, 0) || 
                           3000;
            
            let secondsRemaining = Math.floor(duration / 1000);
            updateCountdown(secondsRemaining);
            
            // Update countdown timer
            state.timers.countdown = setInterval(() => {
                secondsRemaining--;
                updateCountdown(secondsRemaining);
                
                if (secondsRemaining <= 0) {
                    clearInterval(state.timers.countdown);
                }
            }, 1000);
            
            // Start transition timer
            state.timers.transition = setTimeout(() => {
                if (state.currentIndex < mediaFiles.length - 1) {
                    showSlide(state.currentIndex + 1, 'next');
                } else {
                    // Loop to beginning or stop
                    showSlide(0, 'next');
                }
            }, duration);
            
            // Animate progress bar
            let progress = 0;
            const increment = 100 / (duration / 100);
            
            state.timers.progress = setInterval(() => {
                progress += increment;
                elements.progressBar.style.width = Math.min(progress, 100) + '%';
                
                if (progress >= 100) {
                    clearInterval(state.timers.progress);
                }
            }, 100);
            
            // Start pointer animation
            movePointerAlongPath();
            
            // Add audio ended handler as backup
            elements.currentAudio.onended = () => {
                if (state.isPlaying) {
                    if (state.currentIndex < mediaFiles.length - 1) {
                        showSlide(state.currentIndex + 1, 'next');
                    } else {
                        showSlide(0, 'next');
                    }
                }
            };
        }

        // [Rest of the code remains the same...]
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
